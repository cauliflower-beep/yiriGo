## 概述
对于一个项目来说，一个功能的实现往往是需要通过庞大的代码来完成的，而对于程序来说，性能是必不可少的关注话题。
因此，在如此庞大的代码量中分析性能问题是非常重要的

## Go测试种类

golang支持的测试种类有：

| 类型                           | 格式                  | 作用                                                 |
| ------------------------------ | --------------------- | ---------------------------------------------------- |
| 单元测试                       | 函数名前缀为Test      | 测试程序的一些逻辑行为是否正确                       |
| 基准（压力测试）               | 函数名前缀为Benchmark | 测试函数的性能                                       |
| 示例测试                       | 函数名前缀为Example   | 为文档提供示例文档                                   |
| 模糊（随机）测试（高版本才有） | 函数名前缀为Fuzz      | 生成一个随机测试用例，去覆盖人为测不到的各种复杂场景 |

## 日志方法

单元测试框架提供了以下常用的日志方法：

| 方法   | 备注                             |
| ------ | -------------------------------- |
| Log    | 打印日志，同时结束测试           |
| Logf   | 格式化打印日志，同时结束测试     |
| Error  | 打印错误日志，同时结束测试       |
| Errorf | 格式化打印错误日志，同时结束测试 |
| Fatal  | 打印致命日志，同时结束测试       |
| Fatalf | 格式化打印致命日志，同时结束测试 |

## 子测试

自测试是 Go 语言内置支持的。可以在某个测试用例中，根据测试场景使用 t.Run 创建不同的子测试用例。

```go
// 使用案例:
TestMul()
TestDiv()
```



## 辅助函数

对于一些重复的逻辑，抽取出来作为公共的帮助函数（helpers），可以增加测试代码的可读性和可维护性。

借助帮助函数，可以使测试用例的主逻辑看起来更清晰。

```go
// 使用案例：
// 我们可以将创建子测试的逻辑抽取出来
createSubTestCase()
```

关于helper函数的两个建议：

1. 不要返回错误，帮助函数内部直接使用 t.Error 或 t.Fatal 即可，在用例主逻辑中不会因为太多的错误处理代码，影响可读性。
2. 调用 t.Helper() 让报错信息更准确，有助于定位。

## setup 和 teardown

如果在同一个测试文件中，每一个测试用例运行前后的逻辑是相同的，一般会写在 setup 和 teardown 函数中。例如执行前需要实例化待测试的对象，如果这个对象比较复杂，很适合将这一部分逻辑提取出来；执行后，可能会做一些资源回收类的工作。

例如关闭网络连接，释放文件等。

标准库 testing 提供了这样的机制。

使用案例见 setup_test.go

## 网络测试

### TCP/IP

假设需要测试某个 API 接口的 handler 能否正常工作，例如 helloHandler

案例见 net_test.go

可以创建真实的网络链接进行测试