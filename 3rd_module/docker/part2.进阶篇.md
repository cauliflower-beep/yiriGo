## 9.Docker复杂安装

### 9.2安装redis集群

假如业务规模不断扩大，1~2亿条数据需要缓存，如何设计这个存储案例呢?

单机单台100%是不可能的，需要用到分布式存储。用redis如何落地呢？

业界一般有3中解决方案：

1. `哈希取余分区`

   ![hash取余分区](.\imgs\hash取余分区.png)

   - 算法原理

     2亿条记录就是2亿个k-v，单机不行，必须使用分布式多机。假设有3台机器构成一个集群，用户每次读写操作都是根据公式：hash(key) % n 个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。

   - 优点

     简单粗暴，直接有效。只需要预估好数据，规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求，并维护这些请求的信息，起到负载均衡+分而治之的作用。

   - 缺点

     原来规划好的节点，进行扩、缩容就比较麻烦了。不管扩缩，每次数据变动导致节点有变动，映射关系就需要重新计算。在服务器个数固定不变时没有问题，如果需要弹性扩容或者故障停机的情况下，原来的取模公式就会发生变化：hash(key) % 3会变成hash(key) % n?此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。某个redis宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。

2. `一致性哈希算法分区`

   - 算法背景

     一致性哈希算法在1997年在麻省理工学院被提出，设计目标是为了解决分布式缓存数据变动和映射问题。

     某个机器宕机了，分母数量改变了，自然取余数就不ok了。

   - 算法目标

     提出一致性hash解决方案，目的是当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系。

   - 算法实现

     实现一致性哈希算法主要有3大步骤：构建一致性哈希环、节点映射、key到服务器的落键规则。

   - 优点

   - 缺点

     存在数据倾斜问题。

     一致性hash算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜(被缓存的对象大部分集中缓存在某一台服务器上)问题。

   - 总结

     为了在节点数目发生改变时尽可能少的迁移数据，将所有的存储节点排列在首尾相接的hash环上。每个key在计算hash后会顺时针找到临近的存储节点存放。

     而当有节点加入或退出时，仅影响该节点在hash环上顺时针相邻的后续节点。

     缺点是数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。

3. `哈希槽分区`

   - 算法背景

     为了解决一致性哈希算法的数据倾斜问题。哈希槽实质就是一个数组[0, 2^14 - 1]形成的hash slot空间。

   - 算法目标

     为了解决均匀分配的问题，在数据和节点之间又加入了一层，把这层成为哈希槽（slot），用于管理数据和节点之间的关系，相当于节点上放的是槽，槽里放的是数据。

     ![哈希槽](.\imgs\哈希槽.png)

     槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。

     哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。

   - 槽编号

     一个集群只能有16384个槽，编号0~16383（0 ~ 2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。

     可以指定哪些编号的槽分配给哪个主节点，集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对key求hash值，然后对16384取余，余数是n，key就落入对应的槽里。slot = CRC16(key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。

   - 哈希槽计算

## 10.DockerFile解析

### 10.1什么是DockerFile

DockerFile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。

![image-20230328102325536](.\imgs\docker组织结构.png)

官网文档：https://docs.docker.com/engine/reference/builder/

由此可以看出，构建docker容器一般分为三个步骤：

1. 编写 DockerFile 文件

   DockerFile定义了进程需要的一切东西，涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程（当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制）等等。

2. docker build 命令构建镜像

   在用DockerFile定义一个文件之后，docker build时会产生一个Docker镜像，当运行Docker镜像时，会真正开始提供服务。

3. docker run 依镜像运行容器实例

   容器是直接提供服务的。

### 10.2DockerFile构建过程

Docker内容基础：

1. 每条保留字指令都必须为大写字母，且后面要跟随至少一个参数；
2. 指令按照从上到下顺序执行；
3. 注释使用 #
4. 每条指令都会创建一个新的镜像层，并对镜像进行提交

Docker执行DockerFile的大致流程：

1. docker从基础镜像运行一个容器；
2. 执行一条指令并对容器做出修改；
3. 执行类似docker commit的操作提交一个新的镜像层；
4. docker再基于刚提交的镜像运行一个新容器；
5. 执行dockerfile中的下一条指令，直到所有指令都执行完成。

总结：

从应用软件的角度来看，DockerFile、Docker镜像与Docker容器分别代表软件的三个不同阶段。

DockerFile是软件的原材料，Docker镜像是软件的交付品，Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例。

DockerFile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。

### 10.3常用保留字指令

参考 tomcat8 的dockerFile：https://github.com/docker-library/tomcat

- *FROM*

  基础镜像，即当前镜像是基于哪个镜像的。指定一个已经存在的镜像作为模板，第一条必须是from.

- *MAINTAINER*

  镜像维护者的姓名和邮箱地址。

- *RUN*

  容器构建时需要运行的命令。它分为两种格式：

  ```go
  // shell格式
  RUN <命令行命令>
  # <命令行命令>等同于，在终端操作的shell命令
  RUN yum -y install vim
  
  // exec 格式
  RUN ["可执行文件","参数1","参数2"]
  # 例如:
  # RUN ["./test.go","dev","offline"] <=> RUN ./test.go dev offline
  ```

  RUN .docker build.

- EXPOSE

  当前容器对外暴露的端口。

- WORKDIR

  指定在创建容器后，终端默认登陆进来的工作目录，一个初始落脚点。

- USER

  指定该镜像以什么样的用户去执行，如果都不指定，默认是root.

- ENV

  用来在构建镜像的过程中设置环境变量。

  ENV MY_PATH /usr/mytest

  这个环境变量可以在后续的任何 RUN 指令中使用，这就如同在命令前面指定了环境变量前缀一样；也可以在其他指令中直接使用这些环境变量，比如：

  WORKDIR $MY_PATH

- ADD

  将宿主机目录下的文件拷贝进镜像，且会自动处理 URL 和解压 tar 压缩包。

- COPY

  类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中<源路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置。

  ```go
  COPY ["src", "dest"]
  <src 源路径>：源文件或者源目录
  <dest 目标路径>：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。
  ```

- VOLUME

  容器数据卷，用于数据保存和持久化工作。

- CMD

  指定容器启动后要做的事情。CMD 指令的格式和 RUN 相似，也是两种格式：

  ```go
  // shell 格式
  CMD <命令>
  
  // exec格式
  CMD ["可执行文件","参数1","参数2"]
  
  // 参数列表格式：
  CMD ["参数1","参数2"...].在指定了 ENTRYPOINT 指令后，用CMD 指定具体的参数。
  ```

  DockerFile中可以有多个CMD指令，但只有最后一个生效。CMD会被docker run之后的参数替换。

  CMD 是在docker run时运行；RUN是在docker build时运行。

- ENTRYPOINT

  也是用来指定一个容器启动时要运行的命令。

  类似CMD指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当做参数送给 ENTRYPOINT 指令指定的程序。

  ```go
  // 命令格式
  ENTRYPOINT ["<executeable>","<param1>","<param2>"...]
  ```

  ENTRYPOINT可以和CMD一起用，一般是变参才会使用CMD，这里的CMD等于是在给ENTRYPOINT传参。当指定了ENTRYPOINT后，CMD的含义就发生了变化，不再是直接运行其命令，而是将CMD的内容作为参数传递给ENTRYPOINT指令，他两个组合会变成 <ENTRYPOINT> "<CMD>".

  来看个栗子：假设已通过DockerFile 构建了 nginx:test 镜像。

  ```go
  FROM nginx
  
  ENTRYPOINT ["nginx","-c"] // 定参
  CMD ["/etc/nginx/nginx.conf"] // 变参
  ```

  | 是否传参         | 按照DockerFile编写执行         | 传参运行                                     |
  | ---------------- | ------------------------------ | -------------------------------------------- |
  | Docker命令       | docker run nginx:test          | docker run nginx:test -c /etc/nginx/new.conf |
  | 衍生出的实际命令 | nginx -c /etc/nginx/nginx.conf | nginx -c /etc/nginx/new.conf                 |

  这样做的好处是，在执行docker run的时候可以指定 ENTRYPOINT 运行所需的参数。

  需要注意的是，如果DockerFile中存在多个 ENTRYPOINT指令，仅最后一个生效。

### 10.4总结

| BUILD         | Both    | RUN        |
| ------------- | ------- | ---------- |
| FROM          | WORKDIR | CMD        |
| MAINTAINER    | USER    | ENV        |
| COPY          |         | EXPOSE     |
| ADD           |         | VOLUME     |
| RUN           |         | ENTRYPOINT |
| ONBUILD       |         |            |
| .dockerignore |         |            |



## 11.Docker微服务

## 12.Docker网络

## 13.Docker-compose容器编排

## 14.Docker轻量级可视化工具portainer

## 15.Docker容器监控之CAdvisor+InfluxDB+Granfana

## 终章