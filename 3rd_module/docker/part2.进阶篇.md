## 9.Docker复杂安装

### 9.2安装redis集群

假如业务规模不断扩大，1~2亿条数据需要缓存，如何设计这个存储案例呢?

单机单台100%是不可能的，需要用到分布式存储。用redis如何落地呢？

业界一般有3中解决方案：

1. `哈希取余分区`

   ![hash取余分区](.\imgs\hash取余分区.png)

   - 算法原理

     2亿条记录就是2亿个k-v，单机不行，必须使用分布式多机。假设有3台机器构成一个集群，用户每次读写操作都是根据公式：hash(key) % n 个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。

   - 优点

     简单粗暴，直接有效。只需要预估好数据，规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求，并维护这些请求的信息，起到负载均衡+分而治之的作用。

   - 缺点

     原来规划好的节点，进行扩、缩容就比较麻烦了。不管扩缩，每次数据变动导致节点有变动，映射关系就需要重新计算。在服务器个数固定不变时没有问题，如果需要弹性扩容或者故障停机的情况下，原来的取模公式就会发生变化：hash(key) % 3会变成hash(key) % n?此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。某个redis宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。

2. `一致性哈希算法分区`

   - 算法背景

     一致性哈希算法在1997年在麻省理工学院被提出，设计目标是为了解决分布式缓存数据变动和映射问题。

     某个机器宕机了，分母数量改变了，自然取余数就不ok了。

   - 算法目标

     提出一致性hash解决方案，目的是当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系。

   - 算法实现

     实现一致性哈希算法主要有3大步骤：构建一致性哈希环、节点映射、key到服务器的落键规则。

   - 优点

   - 缺点

     存在数据倾斜问题。

     一致性hash算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜(被缓存的对象大部分集中缓存在某一台服务器上)问题。

   - 总结

     为了在节点数目发生改变时尽可能少的迁移数据，将所有的存储节点排列在首尾相接的hash环上。每个key在计算hash后会顺时针找到临近的存储节点存放。

     而当有节点加入或退出时，仅影响该节点在hash环上顺时针相邻的后续节点。

     缺点是数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。

3. `哈希槽分区`

   - 算法背景

     为了解决一致性哈希算法的数据倾斜问题。哈希槽实质就是一个数组[0, 2^14 - 1]形成的hash slot空间。

   - 算法目标

     为了解决均匀分配的问题，在数据和节点之间又加入了一层，把这层成为哈希槽（slot），用于管理数据和节点之间的关系，相当于节点上放的是槽，槽里放的是数据。

     ![哈希槽](.\imgs\哈希槽.png)

     槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。

     哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。

   - 槽编号

     一个集群只能有16384个槽，编号0~16383（0 ~ 2^14-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。

     可以指定哪些编号的槽分配给哪个主节点，集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对key求hash值，然后对16384取余，余数是n，key就落入对应的槽里。slot = CRC16(key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。

   - 哈希槽计算

## 10.DockerFile解析

### 10.1什么是DockerFile

DockerFile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。

![image-20230328102325536](.\imgs\docker组织结构.png)

官网文档：https://docs.docker.com/engine/reference/builder/

由此可以看出，构建docker容器一般分为三个步骤：

1. 编写 DockerFile 文件

   DockerFile定义了进程需要的一切东西，涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程（当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制）等等。

2. docker build 命令构建镜像

   在用DockerFile定义一个文件之后，docker build时会产生一个Docker镜像，当运行Docker镜像时，会真正开始提供服务。

3. docker run 依镜像运行容器实例

   容器是直接提供服务的。

### 10.2DockerFile构建过程

Docker内容基础：

1. 每条保留字指令都必须为大写字母，且后面要跟随至少一个参数；
2. 指令按照从上到下顺序执行；
3. 注释使用 #
4. 每条指令都会创建一个新的镜像层，并对镜像进行提交

Docker执行DockerFile的大致流程：

1. docker从基础镜像运行一个容器；
2. 执行一条指令并对容器做出修改；
3. 执行类似docker commit的操作提交一个新的镜像层；
4. docker再基于刚提交的镜像运行一个新容器；
5. 执行dockerfile中的下一条指令，直到所有指令都执行完成。

总结：

从应用软件的角度来看，DockerFile、Docker镜像与Docker容器分别代表软件的三个不同阶段。

DockerFile是软件的原材料，Docker镜像是软件的交付品，Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例。

DockerFile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。

### 10.3常用保留字指令



## 11.Docker微服务

## 12.Docker网络

## 13.Docker-compose容器编排

## 14.Docker轻量级可视化工具portainer

## 15.Docker容器监控之CAdvisor+InfluxDB+Granfana

## 终章