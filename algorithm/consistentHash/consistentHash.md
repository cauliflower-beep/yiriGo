## 一致性hash算法原理及golang实现

### 需求

​	当集群提供缓存服务时，key应该路由到哪一个服务？

​	这里假如采用最通用的方式key%N(N为服务器数目)，看上去是没问题的。但是一旦服务器数目发生增加或减少时, 分配方式则变为key%(N+1)或key%(N-1)，这里将会有大量的key失效, 为了解决类问题,一致性hash算法应运而生。

​	换言之，在移除/添加一个cache时，一致性hash算法能够尽可能小的改变已存在的 key 的映射关系。

### 特点

- 均衡性(Balance)

  也叫平衡性，是指hash的结果能够尽可能地分布到所有的缓存中去，使得所有的缓存空间都可以得到利用。

  hash算法并不是保证绝对的平衡，如果cache较少的话，对象并不能被均匀的映射到cache上，比如下面的例子，仅仅部署cacheA、cacheC的情况下，cacheC存储了三个对象，cacheA仅存了一个。类似的情况可能更加严重，造成资源利用不均。

- 单调性(Monotonicity)

- 分散性(Spread)

- 负载(Load)

### 详解

​	一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中 K是关键字的数量，n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。

​	一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环，整个哈希空间的取值范围为0~2的32次方-1。整个空间按顺时针方向组织。0~2的32次方-1在零点中方向重合。接下来使用如下算法对服务请求进行映射：

![image-20220817155618894](..\img\image-20220817155618894.png)

1. 将服务请求使用哈希算法算出对应的hash值；

   例如4个对象 object1~object4，则通过hash函数计算得到hash值：

   hash(object1) = key1;

   hash(object2) = key2;

   ...

2. 根据hash值的位置沿圆环顺时针查找，第一台遇到的服务器就是所对应的处理请求服务器；

   处理请求的服务器，也就是具体的cache，它的hash计算一般是使用cache机器的IP地址或者机器名作为hash输入。假设当前有3台cache机器 cacheA、cacheB、cacheC，则分别计算：

   hash(cacheA) = keyA;

   hash(cacheB) = keyB;

   ...

3. 当增加一台新的服务器，受影响的数据仅仅是新添加的服务器到其环空间中前一台的服务器（也就是顺着逆时针方向遇到的第一台服务器）之间的数据，其他都不会受到影响。

   例如 node2 挂了，则影响的是之前映射到 node2上的key，也就是key2、key3.

   增加节点同理。

![1660721017(1)](..\img\1660721017(1).jpg)

综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。

### 改进

​	上面提到的算法存在平衡性问题。

​	如果服务器节点较少，存在某些节点所在位置周围有大量的hash点从而导致分配到这些节点的key要比其他节点多的多，这样会导致集群中各节点负载不均衡，为解决这个问题，引入虚拟节点的概念：

​	“虚拟节点”( virtual node )是实际节点在 hash 空间的复制品( replica )，一个实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。

​	以仅部署 cache A 和 cache C 的情况为例，现在引入虚拟节点，并设置“复制个数”为2，这就意味着一工会存在 4 个“虚拟节点”， cache A1, cache A2 代表了 cache A ； cache C1, cache C2 代表了 cache C ；假设一种比较理想的情况，参见下图:

![1660723904(1)](..\img\1660723904(1).jpg)

此时，对象到“虚拟节点”的映射关系为：

objec1->cache A2 ； objec2->cache A1 ； objec3->cache C1 ； objec4->cache C2 ；

因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache C 上；平衡性有了很大提高。

引入“虚拟节点”后，映射关系就从 { 对象 -> 节点 } 转换到了 { 对象 -> 虚拟节点 } 。查询物体所在 cache 时的映射关系如下图所示。

![1660724024(1)](..\img\1660724024(1).jpg)

“虚拟节点”的 hash 计算可以采用对应节点的 IP 地址加数字后缀的方式。例如假设 cache A 的 IP 地址为202.168.14.241 。

引入“虚拟节点”前，计算 cache A 的 hash 值：

Hash(“202.168.14.241”);

引入“虚拟节点”后，计算“虚拟节”点 cache A1 和 cache A2 的 hash 值：

Hash(“202.168.14.241#1”);  // cache A1

Hash(“202.168.14.241#2”);  // cache A2

### 实现

见 consistentHash.go