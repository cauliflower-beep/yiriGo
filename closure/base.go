package main

import "fmt"

/*
参考连接：https://juejin.cn/post/6844903950504689677
*/
/*
在说明闭包之前，有必要了解一下函数变量。
在go语言中，函数被看作是第一类值，这意味着函数像变量一样，有类型、有值，其他普通变量能做的事它也可以。
换句话说，可以保存函数的地址到变量中，然后通过变量名进行调用。来看一个例子：
这个机制有点类似于其他语言，例如 python 中的 lambda 表达式
*/

var fplus = func(x, y int) int { return x + y }

/*
然后是普通函数。
普通函数的运行环境，要么是仅仅依赖内部变量维持的独立环境，每次运行都会重新初始化，无法实现变量的重复利用，
要么是依赖了外部变量维持的，具有记忆功能的环境，解决了重新初始化的问题，但引入了新的问题：
必须定义作用范围更大的外部环境，增加了维护成本。
来看一个普通函数计算斐波那契数列的例子：
*/
var a, b = 0, 1

func fibWithoutClosure() int { // 运行10次，就可以生成前10位斐波那契数列
	a, b = b, a+b
	return a
}

/*
再来解释闭包，闭包是一种技术，它存储了闭包函数及所需要的环境，而环境分为函数运行时所处的内部环境和依赖的外部环境。
闭包函数被使用者调用时不会像普通函数那样丢失环境。

通俗来讲，闭包产生的条件有两个：
1.函数嵌套函数；
2.变量在外面那个函数声明，在里面那个函数调用。
3.闭包函数就像邻居的房子（局部作用域），你没有权限拿到房子里的物品。但你可以通过邻居（闭包返回的对象）拿到他家的东西
来看闭包怎么处理斐波那契数列的计算：
外部函数的返回值是内部函数，内部函数是一个匿名函数，这个匿名函数的返回值是真正的斐波那契数

可以看到闭包与普通函数的区别：
1.闭包函数内部定义了变量x,y,最终返回的匿名函数中使用了这两个变量；
2.普通函数 fibWithoutClosure 的外部定义了变量a,b,调用该函数使用了外部的变量；
3.闭包函数是延迟计算也就是惰性求值，而普通函数是立即计算，两者的调用方式不一样.
*/

//fibWithClosure
func fibWithClosure() func() int {
	x, y := 0, 1
	return func() int {
		x, y = y, x+y
		return x
	}
}

/*
其实本质上来讲，闭包只是普通函数的嵌套：

func fibWithClosure() func() int {
	x, y := 0, 1
	func fibGenerator()int{
		x, y = y, x+y
		return x
	}
	return fibGenerator
}
只不过Go并不支持函数嵌套，而是使用匿名函数来实现函数嵌套的效果。上述例子只是伪代码
其他一些支持函数嵌套的语言，例如Js，就可以通过上面的形式实现闭包
*/

/*
闭包的作用：
1.保存将要销毁的数据；
2.保密。
说白了，闭包本质是一种垃圾回收机制，变量声明要被销毁时，利用闭包可以手机即将被销毁的数据
*/

/*
问题：
go语言中闭包一定得返回匿名函数吗？
不一定，也可以返回一个对象，对象拥有重置内部变量的方法，以及返回内部变量的方法。关键是得有一个对内部变量的引用
*/

func main() {
	// 调用函数类型的变量
	fmt.Println(fplus(1, 2))

	//普通函数计算斐波那契数列
	for i := 0; i < 10; i++ {
		fmt.Println(fibWithoutClosure())
	}

	//闭包计算斐波那契数列
	fib := fibWithClosure()
	for i := 0; i < 10; i++ {
		fmt.Println(fib())
	}
}
