## 1.Docker简介

## 2.Docker安装

## 3.Docker常用命令

### 3.1帮助启动类命令

- 启动docker：*systemctl start docker*
- 停止docker：*systemctl stop docker*
- 重启docker：*systemctl restart docker*
- 查看docker状态：***systemctl status docker***
- 开机启动：*systemctl enable docker*
- 查看docker概要信息：*docker info*
- 查看docker总体帮助的文档：*docker --help*
- 查看docker命令帮助文档：*docker 具体cmd --help*

### 3.2镜像命令

- `docker images` --列出本地主机上的镜像

  ![image-20230327144956073](.\imgs\image-20230327144956073.png)

  各个选项说明：

  | 选项       | 说明             |
  | ---------- | ---------------- |
  | REPOSITORY | 镜像的仓库源     |
  | TAG        | 镜像的标签版本号 |
  | IMAGE ID   | 镜像ID           |
  | CREATED    | 镜像创建时间     |
  | SIZE       | 镜像大小         |

  同一仓库源可以有多个不同的TAG版本，使用 REPOSITORY:TAG 来定义具体的镜像。

  如果不指定一个镜像的版本标签，例如只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。

  该命令后面有一些可选的options，说明如下:

  | options | 说明                               |
  | ------- | ---------------------------------- |
  | -a      | 列出本地所有的镜像，包含利时映像层 |
  | -q      | 只显示镜像ID                       |

- `docker search` --查询镜像

  该命令会从docker hub上查找镜像。docker hub地址：

  https://hub.docker.com

  ![image-20230327150248024](.\imgs\image-20230327150248024.png)

  执行结果说明：

  | 选项        | 说明         |
  | ----------- | ------------ |
  | NAME        | 镜像名称     |
  | DESCRIPTION | 镜像说明     |
  | STARS       | 点赞数量     |
  | OFFICIAL    | 是否官方     |
  | AUTOMATED   | 是否自动构建 |

  命令options说明：

  | options   | 说明                    |
  | --------- | ----------------------- |
  | --limit n | 只列出n个镜像，默认25个 |

- `docker pull` --下载镜像

  下载某个版本的镜像：*docker pull xxx [:TAG]*

  不带tag的话，默认下载最新版本的镜像。

- `docker system df` --查看镜像/容器/数据卷所占的空间

- `docker rmi` --删除镜像

  删除单个镜像：*docker rmi -f 镜像id*

  删除多个镜像：*docker rmf -f 镜像1:TAG 镜像2:TAG*

  删除全部镜像：*docker rmi -f $(docker images -qa)*

**拓展：docker虚悬镜像是什么？**

仓库名、标签都是<none>的镜像，俗称虚悬镜像（dangling image）。后续Dockerfile章节会具体介绍。

### 3.3容器命令

有镜像才能创建容器，这是一个根本前提：

![容器层级](.\imgs\容器层级.png)

- `docker run [OPTIONS] iMAGE [COMMAND][ARG...]` --新建+启动容器

  | options    | 说明                                                         |
  | ---------- | ------------------------------------------------------------ |
  | --name=" " | 为容器指定一个名称                                           |
  | -d         | 后台运行容器并返回容器ID，即启动守护式容器，多数情况下，我们希望docker服务在后台运行 |
  | -i         | 以交互模式运行容器，通常与-t同时使用                         |
  | -t         | 为容器重新分配一个伪输入终端，通常与-i同时使用，前台有伪终端，等待交互 |
  | -P         | 大写，随机端口映射                                           |
  | -p         | 小写，指定端口映射。hostPort:containerPort                   |

  注意，要找到容器服务，首先要访问主机，也就是 -p 冒号前的端口，然后主机会把这个端口映射到docker内部端口。

  示例:启动一个redis容器

  前台交互式启动：docker run -it redis:6.0.8

  后台守护式启动：docker run -d redis:6.0.8

- `docker logs` --跟容器id，查看容器日志

- `docker ps [OPTIONS]` --列出当前所有正在运行的容器

  | options | 说明                                        |
  | ------- | ------------------------------------------- |
  | -a      | 列出当前所有正在运行的容器+历史运行过的容器 |
  | -l      | 显示最近创建的容器                          |
  | -n      | 显示最近n个创建的容器                       |
  | -q      | 静默模式，只显示容器编号                    |

- `docker top` --跟容器id，查看容器内运行的进程

- `docker inspect` --跟容器ID，查看容器内部细节

- `进入容器`

  *docker exec -it 容器ID bashShell* -- 进入正在运行的容器，并以命令行交互

  exec是在容器中打开新的终端，并且可以启动新的进程。用exit退出，不会导致容器停止。

  ![image-20230327161817397](.\imgs\image-20230327161817397.png)

  *docker attach* --跟容器ID，重新进入正在运行的容器

  attach直接进入容器启动命令的终端，不会启动新的进程。用exit退出，会导致容器的停止。

  ![image-20230327161800589](.\imgs\image-20230327161800589.png)

  推荐使用 *docker exec*，因为退出容器终端，不会导致容器的停止。eg.

  进入正在运行的redis容器实例：*docker exec -it 容器ID/bin/bash*

  一般用 -d 后台启动服务，再用exec进入对应容器实例。

- `退出容器`

  当进入正在运行的容器，并以命令行交互(如在伪终端上跟ubuntu容器交互)时，退出容器有两种方式：

  | 操作     | 说明                   |
  | -------- | ---------------------- |
  | exit     | 退出终端，并停止容器   |
  | ctrl+p+q | 退出终端，但不停止容器 |

- `docker cp 容器ID:容器内路径 目的主机路径` --从容器内拷贝文件到主机上

- `docker start` --跟容器ID或者容器名，启动已经停止运行的容器

- `docker restart` --跟容器ID或者容器名，重启容器

- `docker stop` --跟容器ID或者容器名，停止容器

- `docker kill` --跟容器ID或者容器名，强制停止容器

- `docker rm` --跟容器ID，删除已经停止的容器

  一次性删除多个容器实例：*docker rm -f $(docker ps -a -q)*

  删除全部容器：*docker ps -a -q | xargs docker rm*

## 4.Docker镜像

### 4.1镜像是什么？

镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的全部内容。

我们把应用程序和配置依赖打包好，形成一个可交付的运行环境（包括代码、运行时需要的库、环境变量和配置文件等），这个打包好的运行环境就是image镜像文件。

只有通过这个镜像文件，才能生成Docker容器实例，类似python中依据类去生成对象。

如果从远程库pull一个镜像，大概率会发现，下载过程貌似是一层一层的。这就涉及到UnionFS（联合文件系统了）。

`联合文件系统`是一种分层、轻量级并且高性能的文件系统。它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。

Union文件系统时Docker镜像的基础。镜像可以通过分层来继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。

特性：一次同时加载多个文件系统，但从外面只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。

### 4.2镜像加载原理

docker的镜像实际上是由一层一层的文件系统组成的。这种层级的文件系统称为UnionFS。

todo.

### 4.3为什么镜像分层?

最大的一个好处就是共享资源，方便复制迁移、复用。

比如有多个镜像都从相同的base镜像构建而来，那么Docker Host只需在磁盘上保存一份base镜像；同时内存中也只需加载一份base镜像，就可以为所有容器服务了。并且镜像的每一层都可以被共享。

新镜像是从base镜像一层一层叠加生成的，每安装一个软件，就在现有镜像的基础上增加一层。

### 4.4重点理解

docker镜像层都是只读的，容器层是可写的。

![img](.\imgs\ef8086e041ddb0201a16eedbadd620fd.png)

当容器启动时，一个新的可写层被加载到镜像的顶部，这一层通常被称作"容器层"，容器层之下有个init层，它是docker专门生成的一个内部层，主要存放/etc/hosts、/etc/resolv.conf等文件。

"init层"之下的都叫"镜像层"，它们是只读层。

所有对容器的改动，包括添加、删除、还是修改文件，都只会发生在容器层中。

![img](.\imgs\2021419103002124.jpg)

### 4.5镜像commit

docker commit 提交容器副本，使之成为一个新的镜像：

```go
docker commit -m="提交的描述信息" -a="作者" 容器ID 要创建的目标镜像名:[标签名]
```

例如，Ubuntu原始默认的镜像是不带vim命令的，可以在容器中安装：

```go
apt-get update
apt-get -y install vim
```

安装完成后，commit新镜像：

```go
docker commit -m="add vim cmd" -a="xiaohuaye" 5fa45ds42s xiaohuaye/myUbuntu:1.1
```

启动新镜像的话，会发现已经附带了vim命令。

## 5.本地镜像发布到阿里云

## 6.本地镜像发布到私有云

## 7.Docker容器数据卷

### 7.1什么是容器数据卷？

首先回顾一下pc保存大文件的常用方式：

1. 外置活动硬盘；
2. 网盘，百度云、阿里云等

docker容器也有类似的需求，有时需要完成数据的持久化存储，或者重要资料备份。它采用的方法是映射，将容器内的目录映射到主机目录，以此完成备份或持久化的工作。

`卷`就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统（不属于容器内部），因此能够绕过UnionFS，提供一些用于持续存储或共享数据的特性。

`卷`的设计目的就是数据的持久化，完全独立于容器的生存周期，因此docker不会在容器删除时删除其挂载的数据卷。

下面给出总结，辅助理解：

1. 比较类似于redis中的rdb和aof文件；

2. 将docker容器内的数据保存进宿主机的磁盘中；

3. 运行一个带有容器卷存储功能的容器实例：

   ```go
   docker run -it -privileged=true -v /宿主机绝对路径:/容器内目录 镜像名
   ```

数据卷有如下特点：

1. 数据卷可以在容器之间共享，或重用数据；
2. 卷中的更改可以直接实时生效；
3. 数据卷中的更改不会包含在镜像的更新中；
4. 数据卷的生命周期一直持续到没有容器使用它为止（是不是很熟悉?golang的垃圾回收也有类似的机制）

### 7.2数据卷案例

下面通过案例，演示如何在宿主机和容器之间添加映射关系，也即添加容器数据卷。



## 8.Docker常规安装简介

