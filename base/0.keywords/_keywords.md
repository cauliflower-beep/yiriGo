## select

### 监控case

select 语句用于监控并选择一组case语句，并执行相应的代码。

它看起来类似于 switch 语句，但是所有 case 中的表达式都必须是 channel 的发送或接收操作：

```go
...
select {
	case <-ch1:
		fmt.Println("ch1 ...")
		break
	case <-ch2:
		fmt.Println("ch2 ...")
		break
	default:
		fmt.Println("default process...")
	}
...
```

### deadlock

先看一段代码：

```go
```

## defer

### 是什么

defer 是 Go 语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（包括通过 return 正常结束或者 panic 导致的异常结束）执行。它是 Go 语言里一个非常有用的关键字，能把资源的释放语句与申请语句放到距离相近的位置，从而减少了资源泄漏的情况发生。

举个栗子，编程的时候，经常遇到一些成对操作的场景，比如申请数据库连接、文件、锁等资源，这些资源需要在用完之后释放掉，否则会造成内存泄漏。此时可以在申请资源语句的下一行，直接用 defer 语句来注册函 数结束后执行释放资源的操作。因为这样一颗小小的语法糖，忘写关闭资源语句的情况就大大地减少了。

```go
...
r.mu.Lock()
rand.Intn(param)
r.mu.Unlock()
...
// 看起来这里似乎不使用defer执行Unlock也没什么关系
// 其实不然，中间rand这行代码是可能panic的
// 更严重的情况是，中间这段代码很可能被其他人修改，增加更多逻辑，这完全不可控
// 一旦这种情况发生，就会形成死锁
// 这个例子是为了说明，及时看起来很简单的代码，使用defer也是有必要的
// 因为需求总在变化，代码也总会被修改
```

当然 defer 用得不对，也会造成一些问题甚至故障。此外，defer 会有短暂延迟，对时间要求特别高的程序，需要避免使用它，其他情况一般可以忽略它带来的延迟。

### 执行顺序

每次 defer 语句执行的时候，会把函数**压栈**，函数参数会被复制下来； 当**外层函数**退出时，defer 函数按照定义的顺序**逆序执行**；如果 defer 执行的函数为 nil，会在最终调用函数的时候产生 panic。

也就是说，外层函数return前，defer会按先进后出的顺序执行，原因是后面定义的函数可能会依赖前面的资源，如果前面先执行了，那后面函数的依赖就没有了，可能会出错。

### 细节

defer语句表达式的值在定义时就已经确定了。

defer 后面的函数参数会被复制一份保存起来，真正执行的时候，用到的是这个复制的变量。如果此变量是一个“值”，那么就和定义的时候是一致的。如果此变量是一个“引用”，那就可能和定义的时候不一致。

小节代码：[defer.go](.\defer.go)

return之后的defer函数不能被注册执行。

## return

来看下你最熟悉的代码之一：

```go
return xxx
```

这条语句经过编译之后，实际上生成了三条指令：

1. 返回值 = xxx；
2. 调用 defer 函数；
3. 空 return

其中1、3是`return`语句生成的指令，也就是说return并不是一条原子指令；2是defer定义的语句，可能会操作返回值，进而影响最终结果。
