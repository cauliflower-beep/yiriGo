## 互斥锁

互斥锁是一种常用的控制共享资源访问的方法，Go中使用`sync`包的`Mutex`类型来实现互斥锁。它能够保证同一时间有且只有一个`goroutine`可以进入临界区，访问共享资源，其他的goroutine则在等待锁。

多个goroutine同时等待一个锁时，唤醒的策略是随机的。

互斥锁的问题在于，在读的时候，也会阻塞下一个读线程，读多写少的情况下效率很低。

## 读写锁

很多实际场景下是读多写少的，当我们并发的去读取一个资源，不涉及资源修改的时候，是没必要加锁的。这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用`sync`包中的`RWMutex`实现。

读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的`goroutine`如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个`goroutine`获取写锁之后，其他的`goroutine`无论是获取读锁还是写锁都会等待。

`RWMutex`提供了四个方法：

```go
func (*RWMutex) Lock // 写锁定

func (*RWMutex) Unlock // 写解锁

func (*RWMutex) RLock // 读锁定

func (*RWMutex) RUnlock // 读解锁
```

需要注意的是读写锁适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。

### 读锁可以不加吗？

既然并发场景中读锁可以共享，那跟不加锁有什么区别？可以不加吗？

当然不可以。读锁是读的时候共享，在读-写的时候是互斥的。换言之，共享的读锁是为了锁住写线程，在读的时候不能写。