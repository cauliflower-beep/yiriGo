package main

import "fmt"

/*
go函数返回局部变量的指针是否安全？
一般来说，局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。
但这在go中是安全的，go编译器会将整个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将
内存分配在栈上，而是分配在堆上，因为他们不在栈区，即使释放函数，其内容也不会受影响。
*/

func add(a, b int) *int {
	res := 0
	res = a + b
	/*
		这个例子中，局部变量res发生了逃逸。
		res作为返回值，在main函数中继续使用，因此res指向的内存不能够分配到栈上，随着函数结束而回收，
		只能分配在堆上
		编译时可以借助选项 -gcflags=-m,查看变量逃逸的情况
	*/
	return &res
}

/*
go函数参数传递是值传递还是引用传递？
先说结论：go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。

参数如果是非引用类型(int/string/struct这些)，这样在函数中就无法修改原内容数据；
如果是引用类型(ptr/map/slice/chan等这些)，就可以修改原内容数据。

是否可以修改原内容数据，和传值、传引用没有必然的关系。在c++中，传引用肯定是可以修改原内容数据的，在go语言里，
虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型。

引用类型和引用传递是两个概念，切记！

什么是值传递？
将实参的值传递给形参，形参是实参的一份拷贝，实参和形参的内存地址不同。函数内对形参值内容的修改，是否会影响实参
的值内容，取决于参数是否是引用类型

什么是引用传递？
将实参的地址传递给形参，函数内对形参值内容的修改，将会影响实参的值的内容。Go语言是没有引用传递的。在C++中，函数
参数的传递方式有引用传递。

下面分别针对Go的值类型(int/struct等)、引用类型(ptr/slice/map/channel),验证是否是值传递，以及函数内对形参
的修改是否会修改原内容数据。
*/

func main() {
	fmt.Println(add(1, 2))
}
