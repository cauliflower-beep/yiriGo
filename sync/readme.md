## 锁和sync包

在一些复杂的程序中，通常通过不同线程执行不同应用来实现程序的并发。当不同线程要使用同一个变量时，经常会出现一个问题：无法预知变量被不同线程修改的顺序。这通常被称为`资源竞争`。

如何解决这个问题呢？

经典的做法是一次只让一个线程对共享变量进行操作。当变量（临界区）被一个线程改变时，我们为他上锁，直到这个线程执行完成并解锁后，其他线程才能访问它。

例如map类型，出于对性能的考虑，本身不存在锁的机制，是非线程安全的。

相对简单的情况下，通过使用sync包可以解决同一时间只能一个线程访问变量或map类型数据的问题。如果这种方式导致程序明显变慢或者引起其他问题，我们要重新思考来通过goroutines和channels来解决问题，这是在go语言中提倡的用来实现并发的技术。